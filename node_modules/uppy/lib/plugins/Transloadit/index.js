'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var Plugin = require('../Plugin');
var Client = require('./Client');
var StatusSocket = require('./Socket'

/**
 * Upload files to Transloadit using Tus.
 */
);module.exports = function (_Plugin) {
  _inherits(Transloadit, _Plugin);

  function Transloadit(core, opts) {
    _classCallCheck(this, Transloadit);

    var _this = _possibleConstructorReturn(this, _Plugin.call(this, core, opts));

    _this.type = 'uploader';
    _this.id = 'Transloadit';
    _this.title = 'Transloadit';

    var defaultLocale = {
      strings: {
        creatingAssembly: 'Preparing upload...',
        creatingAssemblyFailed: 'Transloadit: Could not create assembly',
        encoding: 'Encoding...'
      }
    };

    var defaultOptions = {
      waitForEncoding: false,
      waitForMetadata: false,
      signature: null,
      params: null,
      fields: {},
      getAssemblyOptions: function getAssemblyOptions(file, options) {
        return {
          params: options.params,
          signature: options.signature,
          fields: options.fields
        };
      },

      locale: defaultLocale
    };

    _this.opts = _extends({}, defaultOptions, opts);

    _this.locale = _extends({}, defaultLocale, _this.opts.locale);
    _this.locale.strings = _extends({}, defaultLocale.strings, _this.opts.locale.strings);

    _this.prepareUpload = _this.prepareUpload.bind(_this);
    _this.afterUpload = _this.afterUpload.bind(_this);

    if (_this.opts.params) {
      _this.validateParams(_this.opts.params);
    }

    _this.client = new Client();
    _this.sockets = {};
    return _this;
  }

  Transloadit.prototype.validateParams = function validateParams(params) {
    if (!params) {
      throw new Error('Transloadit: The `params` option is required.');
    }

    if (typeof params === 'string') {
      try {
        params = JSON.parse(params);
      } catch (err) {
        // Tell the user that this is not an Uppy bug!
        err.message = 'Transloadit: The `params` option is a malformed JSON string: ' + err.message;
        throw err;
      }
    }

    if (!params.auth || !params.auth.key) {
      throw new Error('Transloadit: The `params.auth.key` option is required. ' + 'You can find your Transloadit API key at https://transloadit.com/accounts/credentials.');
    }
  };

  Transloadit.prototype.getAssemblyOptions = function getAssemblyOptions(fileIDs) {
    var _this2 = this;

    var options = this.opts;
    return Promise.all(fileIDs.map(function (fileID) {
      var file = _this2.core.getFile(fileID);
      var promise = Promise.resolve(options.getAssemblyOptions(file, options));
      return promise.then(function (assemblyOptions) {
        _this2.validateParams(assemblyOptions.params);

        return {
          fileIDs: [fileID],
          options: assemblyOptions
        };
      });
    }));
  };

  Transloadit.prototype.dedupeAssemblyOptions = function dedupeAssemblyOptions(list) {
    var dedupeMap = Object.create(null);
    list.forEach(function (_ref) {
      var fileIDs = _ref.fileIDs,
          options = _ref.options;

      var id = JSON.stringify(options);
      if (dedupeMap[id]) {
        var _dedupeMap$id$fileIDs;

        (_dedupeMap$id$fileIDs = dedupeMap[id].fileIDs).push.apply(_dedupeMap$id$fileIDs, fileIDs);
      } else {
        dedupeMap[id] = {
          options: options,
          fileIDs: [].concat(fileIDs)
        };
      }
    });

    return Object.keys(dedupeMap).map(function (id) {
      return dedupeMap[id];
    });
  };

  Transloadit.prototype.createAssembly = function createAssembly(fileIDs, options) {
    var _this3 = this;

    this.core.log('Transloadit: create assembly');

    return this.client.createAssembly({
      params: options.params,
      fields: options.fields,
      expectedFiles: fileIDs.length,
      signature: options.signature
    }).then(function (assembly) {
      var _extends2;

      _this3.updateState({
        assemblies: _extends(_this3.state.assemblies, (_extends2 = {}, _extends2[assembly.assembly_id] = assembly, _extends2))
      });

      function attachAssemblyMetadata(file, assembly) {
        // Attach meta parameters for the Tus plugin. See:
        // https://github.com/tus/tusd/wiki/Uploading-to-Transloadit-using-tus#uploading-using-tus
        // TODO Should this `meta` be moved to a `tus.meta` property instead?
        // If the MetaData plugin can add eg. resize parameters, it doesn't
        // make much sense to set those as upload-metadata for tus.
        var meta = _extends({}, file.meta, {
          assembly_url: assembly.assembly_url,
          filename: file.name,
          fieldname: 'file'
        }
        // Add assembly-specific Tus endpoint.
        );var tus = _extends({}, file.tus, {
          endpoint: assembly.tus_url
        });
        var transloadit = {
          assembly: assembly.assembly_id
        };
        return _extends({}, file, { meta: meta, tus: tus, transloadit: transloadit });
      }

      var files = _extends({}, _this3.core.state.files);
      fileIDs.forEach(function (id) {
        files[id] = attachAssemblyMetadata(files[id], assembly);
      });

      _this3.core.setState({ files: files });

      _this3.core.emit('transloadit:assembly-created', assembly, fileIDs);

      return _this3.connectSocket(assembly);
    }).then(function () {
      _this3.core.log('Transloadit: Created assembly');
    }).catch(function (err) {
      _this3.core.emit('informer', _this3.opts.locale.strings.creatingAssemblyFailed, 'error', 0

      // Reject the promise.
      );throw err;
    });
  };

  Transloadit.prototype.shouldWait = function shouldWait() {
    return this.opts.waitForEncoding || this.opts.waitForMetadata;
  };

  Transloadit.prototype.findFile = function findFile(uploadedFile) {
    var files = this.core.state.files;
    for (var id in files) {
      if (!files.hasOwnProperty(id)) {
        continue;
      }
      if (files[id].uploadURL === uploadedFile.tus_upload_url) {
        return files[id];
      }
    }
  };

  Transloadit.prototype.onFileUploadComplete = function onFileUploadComplete(assemblyId, uploadedFile) {
    var _extends3;

    var file = this.findFile(uploadedFile);
    this.updateState({
      files: _extends({}, this.state.files, (_extends3 = {}, _extends3[uploadedFile.id] = {
        id: file.id,
        uploadedFile: uploadedFile
      }, _extends3))
    });
    this.core.bus.emit('transloadit:upload', uploadedFile, this.getAssembly(assemblyId));
  };

  Transloadit.prototype.onResult = function onResult(assemblyId, stepName, result) {
    var file = this.state.files[result.original_id];
    // The `file` may not exist if an import robot was used instead of a file upload.
    result.localId = file ? file.id : null;

    this.updateState({
      results: this.state.results.concat(result)
    });
    this.core.bus.emit('transloadit:result', stepName, result, this.getAssembly(assemblyId));
  };

  Transloadit.prototype.onAssemblyFinished = function onAssemblyFinished(url) {
    var _this4 = this;

    this.client.getAssemblyStatus(url).then(function (assembly) {
      var _extends4;

      _this4.updateState({
        assemblies: _extends({}, _this4.state.assemblies, (_extends4 = {}, _extends4[assembly.assembly_id] = assembly, _extends4))
      });
      _this4.core.emit('transloadit:complete', assembly);
    });
  };

  Transloadit.prototype.connectSocket = function connectSocket(assembly) {
    var _this5 = this;

    var socket = new StatusSocket(assembly.websocket_url, assembly);
    this.sockets[assembly.assembly_id] = socket;

    socket.on('upload', this.onFileUploadComplete.bind(this, assembly.assembly_id));
    socket.on('error', function (error) {
      _this5.core.emit('transloadit:assembly-error', assembly, error);
    });

    if (this.opts.waitForEncoding) {
      socket.on('result', this.onResult.bind(this, assembly.assembly_id));
    }

    if (this.opts.waitForEncoding) {
      socket.on('finished', function () {
        _this5.onAssemblyFinished(assembly.assembly_ssl_url);
      });
    } else if (this.opts.waitForMetadata) {
      socket.on('metadata', function () {
        _this5.onAssemblyFinished(assembly.assembly_ssl_url);
        _this5.core.emit('transloadit:complete', assembly);
      });
    }

    return new _Promise(function (resolve, reject) {
      socket.on('connect', resolve);
      socket.on('error', reject);
    }).then(function () {
      _this5.core.log('Transloadit: Socket is ready');
    });
  };

  Transloadit.prototype.prepareUpload = function prepareUpload(fileIDs) {
    var _this6 = this;

    fileIDs.forEach(function (fileID) {
      _this6.core.emit('core:preprocess-progress', fileID, {
        mode: 'indeterminate',
        message: _this6.opts.locale.strings.creatingAssembly
      });
    });

    var createAssembly = function createAssembly(_ref2) {
      var fileIDs = _ref2.fileIDs,
          options = _ref2.options;

      return _this6.createAssembly(fileIDs, options).then(function () {
        fileIDs.forEach(function (fileID) {
          _this6.core.emit('core:preprocess-complete', fileID);
        });
      });
    };

    return this.getAssemblyOptions(fileIDs).then(function (allOptions) {
      return _this6.dedupeAssemblyOptions(allOptions);
    }).then(function (assemblies) {
      return Promise.all(assemblies.map(createAssembly));
    });
  };

  Transloadit.prototype.afterUpload = function afterUpload(fileIDs) {
    var _this7 = this;

    // A file ID that is part of this assembly...
    var fileID = fileIDs[0];

    // If we don't have to wait for encoding metadata or results, we can close
    // the socket immediately and finish the upload.
    if (!this.shouldWait()) {
      var file = this.core.getFile(fileID);
      var socket = this.sockets[file.transloadit.assembly];
      socket.close();
      return Promise.resolve();
    }

    return new _Promise(function (resolve, reject) {
      fileIDs.forEach(function (fileID) {
        _this7.core.emit('core:postprocess-progress', fileID, {
          mode: 'indeterminate',
          message: _this7.opts.locale.strings.encoding
        });
      });

      var onAssemblyFinished = function onAssemblyFinished(assembly) {
        var file = _this7.core.getFile(fileID
        // An assembly for a different upload just finished. We can ignore it.
        );if (assembly.assembly_id !== file.transloadit.assembly) {
          return;
        }
        // Remove this handler once we find the assembly we needed.
        _this7.core.emitter.off('transloadit:complete', onAssemblyFinished

        // TODO set the `file.uploadURL` to a result?
        // We will probably need an option here so the plugin user can tell us
        // which result to pick…?

        );fileIDs.forEach(function (fileID) {
          _this7.core.emit('core:postprocess-complete', fileID);
        });

        resolve();
      };

      var onAssemblyError = function onAssemblyError(assembly, error) {
        var file = _this7.core.getFile(fileID
        // An assembly for a different upload just errored. We can ignore it.
        );if (assembly.assembly_id !== file.transloadit.assembly) {
          return;
        }
        // Remove this handler once we find the assembly we needed.
        _this7.core.emitter.off('transloadit:assembly-error', onAssemblyError

        // Clear postprocessing state for all our files.
        );fileIDs.forEach(function (fileID) {
          _this7.core.emit('core:postprocess-complete', fileID);
        }

        // Reject the `afterUpload()` promise.
        );reject(error);
      };

      _this7.core.on('transloadit:complete', onAssemblyFinished);
      _this7.core.on('transloadit:assembly-error', onAssemblyError);
    });
  };

  Transloadit.prototype.install = function install() {
    this.core.addPreProcessor(this.prepareUpload);
    this.core.addPostProcessor(this.afterUpload);

    this.updateState({
      assemblies: {},
      files: {},
      results: []
    });
  };

  Transloadit.prototype.uninstall = function uninstall() {
    this.core.removePreProcessor(this.prepareUpload);
    this.core.removePostProcessor(this.afterUpload);
  };

  Transloadit.prototype.getAssembly = function getAssembly(id) {
    return this.state.assemblies[id];
  };

  Transloadit.prototype.updateState = function updateState(newState) {
    var transloadit = _extends({}, this.state, newState);

    this.core.setState({ transloadit: transloadit });
  };

  _createClass(Transloadit, [{
    key: 'state',
    get: function get() {
      return this.core.state.transloadit || {};
    }
  }]);

  return Transloadit;
}(Plugin);
//# sourceMappingURL=index.js.map