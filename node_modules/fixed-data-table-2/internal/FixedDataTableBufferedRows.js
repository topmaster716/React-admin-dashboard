"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _react = _interopRequireDefault(require('react'));

var _createReactClass = _interopRequireDefault(require("create-react-class"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _FixedDataTableRowBuffer = _interopRequireDefault(require('./FixedDataTableRowBuffer'));

var _FixedDataTableRow = _interopRequireDefault(require('./FixedDataTableRow'));

var _cx = _interopRequireDefault(require('./cx'));

var _emptyFunction = _interopRequireDefault(require('./emptyFunction'));

var _joinClasses = _interopRequireDefault(require('./joinClasses'));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Copyright Schrodinger, LLC
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableBufferedRows
 * @typechecks
 */
var FixedDataTableBufferedRows = (0, _createReactClass["default"])({
  displayName: 'FixedDataTableBufferedRows',
  propTypes: {
    ariaIndexOffset: _propTypes["default"].number,
    bufferRowCount: _propTypes["default"].number,
    isScrolling: _propTypes["default"].bool,
    defaultRowHeight: _propTypes["default"].number.isRequired,
    firstRowIndex: _propTypes["default"].number.isRequired,
    firstRowOffset: _propTypes["default"].number.isRequired,
    fixedColumns: _propTypes["default"].array.isRequired,
    fixedRightColumns: _propTypes["default"].array.isRequired,
    height: _propTypes["default"].number.isRequired,
    offsetTop: _propTypes["default"].number.isRequired,
    onRowClick: _propTypes["default"].func,
    onRowDoubleClick: _propTypes["default"].func,
    onRowContextMenu: _propTypes["default"].func,
    onRowMouseDown: _propTypes["default"].func,
    onRowMouseUp: _propTypes["default"].func,
    onRowMouseEnter: _propTypes["default"].func,
    onRowMouseLeave: _propTypes["default"].func,
    onRowTouchStart: _propTypes["default"].func,
    onRowTouchEnd: _propTypes["default"].func,
    onRowTouchMove: _propTypes["default"].func,
    rowClassNameGetter: _propTypes["default"].func,
    rowsCount: _propTypes["default"].number.isRequired,
    rowHeightGetter: _propTypes["default"].func,
    subRowHeight: _propTypes["default"].number,
    subRowHeightGetter: _propTypes["default"].func,
    rowExpanded: _propTypes["default"].oneOfType([_propTypes["default"].element, _propTypes["default"].func]),
    rowKeyGetter: _propTypes["default"].func,
    rowPositionGetter: _propTypes["default"].func.isRequired,
    scrollLeft: _propTypes["default"].number.isRequired,
    scrollableColumns: _propTypes["default"].array.isRequired,
    showLastRowBorder: _propTypes["default"].bool,
    width: _propTypes["default"].number.isRequired
  },
  getInitialState: function getInitialState()
  /*object*/
  {
    this._rowBuffer = new _FixedDataTableRowBuffer["default"](this.props.rowsCount, this.props.defaultRowHeight, this.props.height, this._getRowHeight, this.props.bufferRowCount);
    return {
      rowsToRender: this._rowBuffer.getRows(this.props.firstRowIndex, this.props.firstRowOffset)
    };
  },
  componentWillMount: function componentWillMount() {
    this._staticRowArray = [];
    this._initialRender = true;
  },
  componentDidMount: function componentDidMount() {
    setTimeout(this._updateBuffer, 1000);
    this._initialRender = false;
  },
  componentWillReceiveProps: function componentWillReceiveProps(
  /*object*/
  nextProps) {
    if (nextProps.rowsCount !== this.props.rowsCount || nextProps.defaultRowHeight !== this.props.defaultRowHeight || nextProps.height !== this.props.height) {
      this._rowBuffer = new _FixedDataTableRowBuffer["default"](nextProps.rowsCount, nextProps.defaultRowHeight, nextProps.height, this._getRowHeight, this.props.bufferRowCount);
    }

    if (this.props.isScrolling && !nextProps.isScrolling) {
      this._updateBuffer();
    } else {
      this.setState({
        rowsToRender: this._rowBuffer.getRows(nextProps.firstRowIndex, nextProps.firstRowOffset)
      });
    }
  },
  _updateBuffer: function _updateBuffer() {
    if (this._rowBuffer) {
      this.setState({
        rowsToRender: this._rowBuffer.getRowsWithUpdatedBuffer()
      });
    }
  },
  shouldComponentUpdate: function shouldComponentUpdate()
  /*boolean*/
  {
    // Don't add PureRenderMixin to this component please.
    return true;
  },
  componentWillUnmount: function componentWillUnmount() {
    this._rowBuffer = null;
    this._staticRowArray.length = 0;
  },
  render: function render()
  /*object*/
  {
    var props = this.props;
    var rowClassNameGetter = props.rowClassNameGetter || _emptyFunction["default"];
    var rowPositionGetter = props.rowPositionGetter;
    var rowsToRender = this.state.rowsToRender; //Sort the rows, we slice first to avoid changing original

    var sortedRowsToRender = rowsToRender.slice().sort(function (a, b) {
      return a - b;
    });
    var rowPositions = {}; //Row position calculation requires that rows are calculated in order

    sortedRowsToRender.forEach(function (rowIndex) {
      rowPositions[rowIndex] = rowPositionGetter(rowIndex);
    });
    this._staticRowArray.length = rowsToRender.length;
    var baseOffsetTop = props.firstRowOffset - props.rowPositionGetter(props.firstRowIndex) + props.offsetTop;

    for (var i = 0; i < rowsToRender.length; ++i) {
      var rowIndex = rowsToRender[i];

      var currentRowHeight = this._getRowHeight(rowIndex);

      var currentSubRowHeight = this._getSubRowHeight(rowIndex);

      var rowOffsetTop = baseOffsetTop + rowPositions[rowIndex];
      var rowKey = props.rowKeyGetter ? props.rowKeyGetter(rowIndex) : i;
      var hasBottomBorder = rowIndex === props.rowsCount - 1 && props.showLastRowBorder;
      this._staticRowArray[i] = _react["default"].createElement(_FixedDataTableRow["default"], {
        key: rowKey,
        isScrolling: props.isScrolling,
        index: rowIndex,
        ariaIndex: rowIndex + props.ariaIndexOffset,
        width: props.width,
        height: currentRowHeight,
        subRowHeight: currentSubRowHeight,
        rowExpanded: props.rowExpanded,
        scrollLeft: Math.round(props.scrollLeft),
        offsetTop: Math.round(rowOffsetTop),
        fixedColumns: props.fixedColumns,
        fixedRightColumns: props.fixedRightColumns,
        scrollableColumns: props.scrollableColumns,
        onClick: props.onRowClick,
        onDoubleClick: props.onRowDoubleClick,
        onContextMenu: props.onRowContextMenu,
        onMouseDown: props.onRowMouseDown,
        onMouseUp: props.onRowMouseUp,
        onMouseEnter: props.onRowMouseEnter,
        onMouseLeave: props.onRowMouseLeave,
        onTouchStart: props.onRowTouchStart,
        onTouchEnd: props.onRowTouchEnd,
        onTouchMove: props.onRowTouchMove,
        showScrollbarY: props.showScrollbarY,
        className: (0, _joinClasses["default"])(rowClassNameGetter(rowIndex), (0, _cx["default"])('public/fixedDataTable/bodyRow'), (0, _cx["default"])({
          'fixedDataTableLayout/hasBottomBorder': hasBottomBorder,
          'public/fixedDataTable/hasBottomBorder': hasBottomBorder
        }))
      });
    }

    return _react["default"].createElement("div", null, this._staticRowArray);
  },
  _getRowHeight: function _getRowHeight(
  /*number*/
  index)
  /*number*/
  {
    return this.props.rowHeightGetter ? this.props.rowHeightGetter(index) : this.props.defaultRowHeight;
  },
  _getSubRowHeight: function _getSubRowHeight(
  /*number*/
  index)
  /*number*/
  {
    return this.props.subRowHeightGetter ? this.props.subRowHeightGetter(index) : this.props.subRowHeight;
  }
});
var _default = FixedDataTableBufferedRows;
exports["default"] = _default;