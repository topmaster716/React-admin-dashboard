"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _FixedDataTableCellDefault = _interopRequireDefault(require('./FixedDataTableCellDefault'));

var _FixedDataTableColumnReorderHandle = _interopRequireDefault(require('././FixedDataTableColumnReorderHandle'));

var _FixedDataTableHelper = _interopRequireDefault(require('./FixedDataTableHelper'));

var _react = _interopRequireDefault(require('react'));

var _createReactClass = _interopRequireDefault(require("create-react-class"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _cx = _interopRequireDefault(require('./cx'));

var _joinClasses = _interopRequireDefault(require('./joinClasses'));

var _shallowEqual = _interopRequireDefault(require('./shallowEqual'));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var DIR_SIGN = _FixedDataTableHelper["default"].DIR_SIGN;
var DEFAULT_PROPS = {
  align: 'left',
  highlighted: false
};
var FixedDataTableCell = (0, _createReactClass["default"])({
  displayName: 'FixedDataTableCell',

  /**
   * PropTypes are disabled in this component, because having them on slows
   * down the FixedDataTable hugely in DEV mode. You can enable them back for
   * development, but please don't commit this component with enabled propTypes.
   */
  propTypes_DISABLED_FOR_PERFORMANCE: {
    isScrolling: _propTypes["default"].bool,
    align: _propTypes["default"].oneOf(['left', 'center', 'right']),
    className: _propTypes["default"].string,
    highlighted: _propTypes["default"].bool,
    width: _propTypes["default"].number.isRequired,
    minWidth: _propTypes["default"].number,
    maxWidth: _propTypes["default"].number,
    height: _propTypes["default"].number.isRequired,
    cell: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].element, _propTypes["default"].func]),
    columnKey: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].number]),

    /**
     * The row index that will be passed to `cellRenderer` to render.
     */
    rowIndex: _propTypes["default"].number.isRequired,

    /**
     * Callback for when resizer knob (in FixedDataTableCell) is clicked
     * to initialize resizing. Please note this is only on the cells
     * in the header.
     * @param number combinedWidth
     * @param number left
     * @param number width
     * @param number minWidth
     * @param number maxWidth
     * @param number|string columnKey
     * @param object event
     */
    onColumnResize: _propTypes["default"].func,
    onColumnReorder: _propTypes["default"].func,

    /**
     * The left offset in pixels of the cell.
     */
    left: _propTypes["default"].number,

    /**
     * Flag for enhanced performance check
     */
    pureRendering: _propTypes["default"].bool,

    /**
     * Whether touch is enabled or not.
     */
    touchEnabled: _propTypes["default"].bool,

    /**
     * Whether cell is in a header or footer row or not
     */
    isHeaderOrFooter: _propTypes["default"].bool
  },
  getInitialState: function getInitialState() {
    return {
      isReorderingThisColumn: false,
      displacement: 0,
      reorderingDisplacement: 0
    };
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
    if (nextProps.isScrolling && this.props.rowIndex === nextProps.rowIndex) {
      return false;
    } //Performance check not enabled


    if (!nextProps.pureRendering) {
      return true;
    }

    var _this$props = this.props,
        oldCell = _this$props.cell,
        oldIsScrolling = _this$props.isScrolling,
        oldProps = _objectWithoutProperties(_this$props, ["cell", "isScrolling"]);

    var newCell = nextProps.cell,
        newIsScrolling = nextProps.isScrolling,
        newProps = _objectWithoutProperties(nextProps, ["cell", "isScrolling"]);

    if (!(0, _shallowEqual["default"])(oldProps, newProps)) {
      return true;
    }

    if (!oldCell || !newCell || oldCell.type !== newCell.type) {
      return true;
    }

    if (!(0, _shallowEqual["default"])(oldCell.props, newCell.props)) {
      return true;
    }

    return false;
  },
  componentWillReceiveProps: function componentWillReceiveProps(props) {
    var left = props.left + this.state.displacement;
    var newState = {
      isReorderingThisColumn: false
    };

    if (props.isColumnReordering) {
      var originalLeft = props.columnReorderingData.originalLeft;
      var reorderCellLeft = originalLeft + props.columnReorderingData.dragDistance;
      var farthestPossiblePoint = props.columnGroupWidth - props.columnReorderingData.columnWidth; // ensure the cell isn't being dragged out of the column group

      reorderCellLeft = Math.max(reorderCellLeft, 0);
      reorderCellLeft = Math.min(reorderCellLeft, farthestPossiblePoint);

      if (props.columnKey === props.columnReorderingData.columnKey) {
        newState.displacement = reorderCellLeft - props.left;
        newState.isReorderingThisColumn = true;
      } else {
        var reorderCellRight = reorderCellLeft + props.columnReorderingData.columnWidth;
        var reorderCellCenter = reorderCellLeft + props.columnReorderingData.columnWidth / 2;
        var centerOfThisColumn = left + props.width / 2;
        var cellIsBeforeOneBeingDragged = reorderCellCenter > centerOfThisColumn;
        var cellWasOriginallyBeforeOneBeingDragged = originalLeft > props.left;
        var changedPosition = false;
        var dragPoint, thisCellPoint;

        if (cellIsBeforeOneBeingDragged) {
          if (reorderCellLeft < centerOfThisColumn) {
            changedPosition = true;

            if (cellWasOriginallyBeforeOneBeingDragged) {
              newState.displacement = props.columnReorderingData.columnWidth;
            } else {
              newState.displacement = 0;
            }
          }
        } else {
          if (reorderCellRight > centerOfThisColumn) {
            changedPosition = true;

            if (cellWasOriginallyBeforeOneBeingDragged) {
              newState.displacement = 0;
            } else {
              newState.displacement = props.columnReorderingData.columnWidth * -1;
            }
          }
        }

        if (changedPosition) {
          if (cellIsBeforeOneBeingDragged) {
            if (!props.columnReorderingData.columnAfter) {
              props.columnReorderingData.columnAfter = props.columnKey;
            }
          } else {
            props.columnReorderingData.columnBefore = props.columnKey;
          }
        } else if (cellIsBeforeOneBeingDragged) {
          props.columnReorderingData.columnBefore = props.columnKey;
        } else if (!props.columnReorderingData.columnAfter) {
          props.columnReorderingData.columnAfter = props.columnKey;
        }
      }
    } else {
      newState.displacement = 0;
    }

    this.setState(newState);
  },
  getDefaultProps: function getDefaultProps()
  /*object*/
  {
    return DEFAULT_PROPS;
  },
  render: function render()
  /*object*/
  {
    var _this$props2 = this.props,
        height = _this$props2.height,
        width = _this$props2.width,
        columnKey = _this$props2.columnKey,
        isHeaderOrFooter = _this$props2.isHeaderOrFooter,
        props = _objectWithoutProperties(_this$props2, ["height", "width", "columnKey", "isHeaderOrFooter"]);

    var style = {
      height: height,
      width: width
    };

    if (DIR_SIGN === 1) {
      style.left = props.left;
    } else {
      style.right = props.left;
    }

    if (this.state.isReorderingThisColumn) {
      style.transform = "translateX(".concat(this.state.displacement, "px) translateZ(0)");
      style.zIndex = 1;
    }

    var className = (0, _joinClasses["default"])((0, _cx["default"])({
      'fixedDataTableCellLayout/main': true,
      'fixedDataTableCellLayout/lastChild': props.lastChild,
      'fixedDataTableCellLayout/alignRight': props.align === 'right',
      'fixedDataTableCellLayout/alignCenter': props.align === 'center',
      'public/fixedDataTableCell/alignRight': props.align === 'right',
      'public/fixedDataTableCell/highlighted': props.highlighted,
      'public/fixedDataTableCell/main': true,
      'public/fixedDataTableCell/hasReorderHandle': !!props.onColumnReorder,
      'public/fixedDataTableCell/reordering': this.state.isReorderingThisColumn
    }), props.className);
    var columnResizerComponent;

    if (props.onColumnResize) {
      var suppress = function suppress(event) {
        event.preventDefault();
        event.stopPropagation();
      };

      var columnResizerStyle = {
        height: height
      };
      ;
      columnResizerComponent = _react["default"].createElement("div", {
        className: (0, _cx["default"])('fixedDataTableCellLayout/columnResizerContainer'),
        style: columnResizerStyle,
        onMouseDown: this._onColumnResizerMouseDown,
        onTouchStart: this.props.touchEnabled ? this._onColumnResizerMouseDown : null,
        onTouchEnd: this.props.touchEnabled ? suppress : null,
        onTouchMove: this.props.touchEnabled ? suppress : null
      }, _react["default"].createElement("div", {
        className: (0, _joinClasses["default"])((0, _cx["default"])('fixedDataTableCellLayout/columnResizerKnob'), (0, _cx["default"])('public/fixedDataTableCell/columnResizerKnob')),
        style: columnResizerStyle
      }));
    }

    var columnReorderComponent;

    if (props.onColumnReorder) {
      //header row
      columnReorderComponent = _react["default"].createElement(_FixedDataTableColumnReorderHandle["default"], _extends({
        columnKey: this.columnKey,
        touchEnabled: this.props.touchEnabled,
        onMouseDown: this._onColumnReorderMouseDown,
        onTouchStart: this._onColumnReorderMouseDown,
        height: height
      }, this.props));
    }

    var cellProps = {
      columnKey: columnKey,
      height: height,
      width: width
    };

    if (props.rowIndex >= 0) {
      cellProps.rowIndex = props.rowIndex;
    }

    var content;

    if (_react["default"].isValidElement(props.cell)) {
      content = _react["default"].cloneElement(props.cell, cellProps);
    } else if (typeof props.cell === 'function') {
      content = props.cell(cellProps);
    } else {
      content = _react["default"].createElement(_FixedDataTableCellDefault["default"], cellProps, props.cell);
    }

    var role = isHeaderOrFooter ? "columnheader" : "gridcell";
    return _react["default"].createElement("div", {
      className: className,
      style: style,
      role: role
    }, columnResizerComponent, columnReorderComponent, content);
  },
  _onColumnResizerMouseDown: function _onColumnResizerMouseDown(
  /*object*/
  event) {
    this.props.onColumnResize(this.props.left, this.props.width, this.props.minWidth, this.props.maxWidth, this.props.columnKey, event);
    /**
     * This prevents the rows from moving around when we resize the
     * headers on touch devices.
     */

    if (this.props.touchEnabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  },
  _onColumnReorderMouseDown: function _onColumnReorderMouseDown(
  /*object*/
  event) {
    this.props.onColumnReorder(this.props.columnKey, this.props.width, this.props.left, event);
  }
});
var _default = FixedDataTableCell;
exports["default"] = _default;