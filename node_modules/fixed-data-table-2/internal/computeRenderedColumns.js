/**
 * Copyright Schrodinger, LLC
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule computeRenderedColumns
 */

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = computeRenderedColumns;

var _clamp = require('lodash/clamp');

var _clamp2 = _interopRequireDefault(_clamp);

var _columnWidths4 = require('./columnWidths');

var _columnWidths5 = _interopRequireDefault(_columnWidths4);

var _virtualizationHelper = require('./virtualizationHelper');

var _virtualizationHelper2 = _interopRequireDefault(_virtualizationHelper);

var _updateColumnWidth = require('./updateColumnWidth');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function computeRenderedColumns(state, columnAnchor) {
  // clone state
  var newState = _extends({}, state);

  // get buffer and viewport range
  var columnRange = calculateRenderedColumnRange(newState, columnAnchor);

  // update the offsets and buffer mapping
  computeRenderedColumnOffsets(newState, columnRange, newState.scrolling);

  // scrollX might have changed due to change in columns and offsets
  var scrollX = state.scrollX;
  if (columnRange.firstViewportCol !== columnRange.endViewportCol) {
    scrollX = newState.columnOffsets[columnRange.firstViewportCol] - newState.firstColumnOffset;
  }

  var _columnWidths = (0, _columnWidths5.default)(state),
      maxScrollX = _columnWidths.maxScrollX;

  newState.maxScrollX = maxScrollX;
  newState.scrollX = (0, _clamp2.default)(scrollX, 0, maxScrollX);

  // for column groups, update buffer and viewport range, buffer mapping, and offsets
  calculateRenderedColumnGroups(newState, columnAnchor, columnRange);

  return newState;
}

/**
 * Determine the range of columns to render (buffer and viewport)
 * The leading and trailing buffer is based on a fixed count,
 * while the viewport columns are based on their width and the viewport width.
 * We use the columnAnchor to determine what either the first or last column
 * will be, as well as the offset.
 *
 * NOTE (jordan) This alters state so it shouldn't be called
 * without state having been cloned first.
 *
 * @param {!Object} state
 * @param {{
 *   firstIndex: number,
 *   firstOffset: number,
 *   lastIndex: number,
 * }} columnAnchor
 * @return {{
 *   endBufferCol: number,
 *   endViewportCol: number,
 *   firstBufferCol: number,
 *   firstViewportCol: number,
 * }}
 * @private
 */
function calculateRenderedColumnRange(state, columnAnchor) {
  var bufferColumnCount = 0; // TODO (pradeep): calculate this similar to bufferRowCount

  var _columnWidths2 = (0, _columnWidths5.default)(state),
      availableScrollWidth = _columnWidths2.availableScrollWidth,
      scrollableColumns = _columnWidths2.scrollableColumns;

  var columnCount = scrollableColumns.length;

  if (availableScrollWidth === 0 || columnCount === 0) {
    return {
      endBufferCol: 0,
      endViewportCol: 0,
      firstBufferCol: 0,
      firstViewportCol: 0
    };
  }

  // If our first or last index is greater than our columnCount,
  // treat it as if the last column is at the end of the viewport
  var firstIndex = columnAnchor.firstIndex,
      firstOffset = columnAnchor.firstOffset,
      lastIndex = columnAnchor.lastIndex;

  if (firstIndex >= columnCount || lastIndex >= columnCount) {
    lastIndex = columnCount - 1;
  }

  // Walk the viewport until filled with columns
  // If lastIndex is set, walk backward so that column is the last in the viewport
  var step = 1;
  var startIdx = firstIndex;
  var totalWidth = firstOffset;
  if (lastIndex !== undefined) {
    step = -1;
    startIdx = lastIndex;
    totalWidth = 0;
  }

  // Loop to walk the viewport until we've touched enough columns to fill its width
  var columnIdx = startIdx;
  var endIdx = columnIdx;
  while (columnIdx < columnCount && columnIdx >= 0 && totalWidth < availableScrollWidth) {
    totalWidth += (0, _updateColumnWidth.updateColumnWidth)(state, columnIdx);
    endIdx = columnIdx;
    columnIdx += step;
  }

  // Loop to walk the leading buffer
  var firstViewportCol = Math.min(startIdx, endIdx);
  var firstBufferCol = Math.max(firstViewportCol - bufferColumnCount, 0);
  for (columnIdx = firstBufferCol; columnIdx < firstViewportCol; columnIdx++) {
    (0, _updateColumnWidth.updateColumnWidth)(state, columnIdx);
  }

  // Loop to walk the trailing buffer
  var endViewportCol = Math.max(startIdx, endIdx) + 1;
  var endBufferCol = Math.min(endViewportCol + bufferColumnCount, columnCount);
  for (columnIdx = endViewportCol; columnIdx < endBufferCol; columnIdx++) {
    (0, _updateColumnWidth.updateColumnWidth)(state, columnIdx);
  }

  // Calculate offset needed to position column at the end of viewport
  // This should be negative and represent how far the first column needs to be offscreen
  if (lastIndex !== undefined) {
    firstOffset = Math.min(availableScrollWidth - totalWidth, 0);
  }

  state.firstColumnIndex = firstViewportCol;
  state.endColumnIndex = endViewportCol;
  state.firstColumnOffset = firstOffset;

  return {
    endBufferCol: endBufferCol,
    endViewportCol: endViewportCol,
    firstBufferCol: firstBufferCol,
    firstViewportCol: firstViewportCol
  };
}

/**
 * Determine the range amd offsets of column groups to be rendered (buffer and viewport)
 *
 * NOTE (jordan) This alters state so it shouldn't be called
 * without state having been cloned first.
 *
 * @param {!Object} state
 * @param {{
 *   firstIndex: number,
 *   firstOffset: number,
 *   lastIndex: number,
 * }} columnAnchor
 * @param {{
 *   endBufferCol: number,
 *   endViewportCol: number,
 *   firstBufferCol: number,
 *   firstViewportCol: number,
 * }} columnRange
 * @private
 */
function calculateRenderedColumnGroups(state, columnAnchor, columnRange) {
  var bufferColumnCount = 0; // TODO (pradeep): calculate this similar to bufferRowCount
  var columnGroupBufferSet = state.columnGroupBufferSet,
      columnGroupOffsetIntervalTree = state.columnGroupOffsetIntervalTree;

  var _columnWidths3 = (0, _columnWidths5.default)(state),
      availableScrollWidth = _columnWidths3.availableScrollWidth,
      scrollableColumns = _columnWidths3.scrollableColumns,
      scrollableColumnGroups = _columnWidths3.scrollableColumnGroups,
      columnGroupIndex = _columnWidths3.columnGroupIndex;

  var columnCount = scrollableColumns.length;
  var columnGroupCount = scrollableColumnGroups.length;

  if (columnCount === 0 || columnGroupCount === 0) {
    state.firstColumnGroupIndex = 0;
    state.endColumnGroupIndex = 0;
    state.columnGroupsToRender = [];
    state.columnGroupOffsets = {};
    return;
  }

  // get first and last scrollable columns in the view port
  var startScrollableColumn = scrollableColumns[Math.max(0, columnRange.firstViewportCol)];
  var endScrollableColumn = scrollableColumns[Math.max(0, columnRange.endViewportCol - 1)];

  // now get the first and last scrollable group column's index in the view port
  var startIdx = columnGroupIndex[startScrollableColumn.groupIdx];
  var endIdx = columnGroupIndex[endScrollableColumn.groupIdx] + 1;

  // output for this function
  var columns = []; // state.columnsToRender
  var columnOffsets = {}; // state.columnOffsets

  // update offsets for the columns
  var totalWidth = columnAnchor.firstOffset;
  for (var currentIdx = startIdx; currentIdx < endIdx; currentIdx++) {
    totalWidth += (0, _updateColumnWidth.updateColumnGroupWidth)(state, currentIdx);

    // no need to calculate if viewport has been filled
    if (totalWidth >= availableScrollWidth) {
      break;
    }
  }

  var renderedColumnsCount = endIdx - startIdx + 2 * bufferColumnCount;

  // incremental way for calculating columnOffset
  var runningOffset = columnGroupOffsetIntervalTree.sumUntil(startIdx);

  // compute column index and offsets for every columns inside the viewport
  for (var columnIdx = startIdx; columnIdx < endIdx; columnIdx++) {
    // Update the offset for rendering the column
    columnOffsets[columnIdx] = runningOffset;
    runningOffset += columnGroupOffsetIntervalTree.get(columnIdx);

    // Get position for the viewport column
    var columnPosition = addColumnToBuffer(columnIdx, columnGroupBufferSet, startIdx, endIdx, renderedColumnsCount);
    columns[columnPosition] = columnIdx;
  }

  state.firstColumnGroupIndex = startIdx;
  state.endColumnGroupIndex = endIdx;
  state.columnGroupsToRender = columns;
  state.columnGroupOffsets = columnOffsets;
}

/**
 * Walk the columns to render and compute the width offsets and
 * positions in the column buffer.
 *
 * NOTE (jordan) This alters state so it shouldn't be called
 * without state having been cloned first.
 *
 * @param {!Object} state
 * @param {{
 *   endBufferCol: number,
 *   endViewportCol: number,
 *   firstBufferCol: number,
 *   firstViewportCol: number,
 * }} columnRange
 * @param {boolean} viewportOnly
 * @private
 */
function computeRenderedColumnOffsets(state, columnRange, viewportOnly) {
  var columnBufferSet = state.columnBufferSet,
      columnOffsetIntervalTree = state.columnOffsetIntervalTree;
  var endBufferCol = columnRange.endBufferCol,
      endViewportCol = columnRange.endViewportCol,
      firstBufferCol = columnRange.firstBufferCol,
      firstViewportCol = columnRange.firstViewportCol;


  var renderedColumnsCount = endBufferCol - firstBufferCol;
  if (renderedColumnsCount === 0) {
    state.columnOffsets = {};
    state.columnsToRender = [];
    return;
  }

  var startIdx = viewportOnly ? firstViewportCol : firstBufferCol;
  var endIdx = viewportOnly ? endViewportCol : endBufferCol;

  var _computeVirtualizedEl = (0, _virtualizationHelper2.default)(columnBufferSet, columnOffsetIntervalTree, startIdx, endIdx, renderedColumnsCount),
      elements = _computeVirtualizedEl.elements,
      elementOffsets = _computeVirtualizedEl.elementOffsets;

  // now we modify the state with the newly calculated columns and offsets


  state.columnsToRender = elements;
  state.columnOffsets = elementOffsets;
}